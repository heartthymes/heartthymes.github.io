## Arrays
Like in many other languages, arrays in go are immutable fixed-length series of elements
```go
//Declare an array of 10 integers
var a [10]int
//Setting first element to 9
a[0] = 9
//Two dimentional array
var twoD [2][3]int
//Declare and initialize
primes := [6]int{2, 3, 5, 7, 11, 13}
```
## Slices
A slice is a dynamically-sized, flexible view into the elements of an array.
```go
a := make([]int, 3) // Int slice of length 3, zero-valued [0, 0, 0]
b := make([]int, 3, 5) // Int slice of length 3 and capacity 5
a[0] = 1 // Setting and getting are the same as for an array [1, 0, 0]
a = append(a, 1, 2) // [1, 0, 0, 1, 2]
```
Slices are half-open, first element is included, last - excluded.
```go
primes := [6]int{2, 3, 5, 7, 11, 13}
var s []int = primes[1:4] // Elements from 1 to 3
```
Slices are views on an underlying array. It doesn't contain any data. Modifying values will modify them in the underlying array.
```go
// This will create an array
[3]bool{true, false, true}
//This will create the same array and then build a slice that references it
[]bool{true, false, true}
```
Slices can contain structs
```go
s := []struct {
		i int
		b bool
	}{
		{2, true},
		{3, false},
		{5, true},
		{7, true},
		{11, false},
		{13, true},
	}
```
Slices a populated with default values if nothing provided. These expressions are equivalent:
```go
a[0:10]
a[:10]
a[0:]
a[:]
```
Slices contain both length and capacity. Length - is the number of elements it contains. And capacity - is the number of elements in the underlying array.
```go
	s := [3]int{1, 2, 3}
	a := s[0:1]
	len(a) // Slice length
	cap(a) // Slice capacity
```
There are also nil slices
```go
var s []int // Nil slice
```

## Variable slices
## Hash tables
## Maps
Maps are key/value data type
```go
m := make(map[string]int) // Create a nil map of string keys and int value
m1 := make(map[int]int){1:1, 2:1, 4:2} // Create and initialize map 
m["key1"] = 1 // Set the value for the key
v1 := m["key1"] // Get the value for the key

delete(m, "key1") // Removes key/value pair from the map

_, prs := m["key1"] // Second return on getting an element indicates if the key was present in the map
```
## Structs
Struct is a mutable collection of fields.
```go
// Struct declaration
type Vertex struct {
	X int
	Y int
}
// Struct initialization
p := Vertex{1, 2}
// Struct field mutation
p.X = 4

v := Vertex{1, 2}
p := &v
p.X = 1e9 // Shortened version of (*p).X. Using pointer.

v1 = Vertex{1, 2}  // has type Vertex
v2 = Vertex{X: 1}  // Y:0 is implicit
v3 = Vertex{}      // X:0 and Y:0
p  = &Vertex{1, 2} // has type *Vertex
```
## RFCs
## JSON
## File Access, ioutil
## File Access, os
## Why use functions?
Functions are isolated sets of instructions, e.g.
```go
//declaration
func PrintHello() { //name
	fmt.Printf("Hello, World.") //set of instructions
}

func main() {
	PrintHello() //call
}
```
Functions are good for:
- Reusability
- Readability
- Maintainability
- Testing
and other purposes.
## Function Parameters and Return
Functions in go are declared the same way they are everywhere:
```go
func foo() { // zero parameter func
}

func foo(x int, y int) { // two parameter func
	fmt.Print(x * y)
}

func foo(x, y int) { // shortened parameter declaration (they are of the same type)
}

func foo (x int) int { // return value type after parameter declaration
	return x + 1
}

func foo (x int) (int, int) { // multiple return value types
	return x, x + 1 // multiple return values
}

d, v := foo(2) // call for the function returning more than one value

y := foo(1) // call

func main() {
	foo(2, 3) //call
}
```
## Call By Value, Reference
## Passing Arrays and Slices
## Well-Written Functions
## Guidelines for Functions
## Function Guidelines
## First Class Values
## Returning Functions
## Variadic and Deferred
## Classes and Encapsulation
## Support for Classes (1)
## Support for Classes (2)
## Encapsulation
## Point Receivers
## Point Receivers, Referencing, Dereferencing
## Polymorphism
## Interfaces
## Interface vs Concrete Types
## Using Interfaces
## Type Assertions
## Error Handling